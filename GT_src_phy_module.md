# 讲解代码Phy_module及其子模块

![image](https://github.com/Vikkdsun/GT/assets/114153159/7366e29d-6a9a-4574-b7a1-3eb5ac1fe551)

## Phy_tx

![image](https://github.com/Vikkdsun/GT/assets/114153159/3b593a74-7cf2-45a5-b248-6bd862fd0f10)

该模块的作用是链接用户端和GT端，我们设定用户端使用AXI_STREAM总线形式将数据发送到本模块，本模块对得到的数据组上同步码、起始码、结束码，再发送到GT收发器

![image](https://github.com/Vikkdsun/GT/assets/114153159/e5410e2a-7ebf-4c38-84c8-59f265849097)

上图我们设为***图一***，图中展示的就是我们想要发给GT的数据格式，其中红色代表***同步码***，蓝色代表***起始码、结束码***，黑色是数据,X代表我们不关心的数据，空格之间的数据为1Byte

![image](https://github.com/Vikkdsun/GT/assets/114153159/5b76ce3c-70b3-4f07-b53a-e0776b631717)

AXI_STREAM传过来的数据主要有以上两个主要信号，上面的代表数据，下面的代表掩码，由于D10后的数据不是用户端想要发送的，所以掩码为这Byte设为0

了解了大概的传输目的，我们要讨论的**第一个点**是：***最后一个数据的掩码可能***

![image](https://github.com/Vikkdsun/GT/assets/114153159/5d9c54e2-00cc-41e5-86c4-b96a81faee59)

图中给出了四种掩码可能，我们只在乎最后一个数据（32bit）的掩码，因为如果传输一个32bit，那么最后一个就是它自身，传输两个32bit，那么第一个32bit一定掩码全1，这也是AXI_STREAM的特点

根据图一我们知道，在组包过程中，FB会使得数据整体后移一位，那么对这四种情况分别讨论：

![image](https://github.com/Vikkdsun/GT/assets/114153159/6e03d718-eac4-4e75-a4a4-bd5a5edc9897)

上图我们设为***图二***，从图中可以看到，虽然AXI发过来的32bit数据个数相同，但是发给GT会变成不同个数，而这种个数的区别就是由AXI发过来的掩码造成的

在写程序时，我们对于组包操作，一般采用***状态机*** + ***FIFO***方式，也就是，发送BC 50 BC 50一个状态、发送FB一个状态（但是实际上这个状态一定也会发送数据）、接着就是发送数据的状态、最后是发送FD的状态（这个状态可能发送数据也可能只发送FB）

我们首先确定一下什么时候进入第一个状态，

![image](https://github.com/Vikkdsun/GT/assets/114153159/5964ab59-8def-4492-af5c-bc2f5e7a934c)

上图我们设为***图三***从图中可以看到，为了数据进入FIFO至少两个周期，我们将在图中位置开始读使能。

我们尝试着画下状态机的时序：

因为发送时32bit数据的长度会+1或不变，所以我们在考虑发送数据状态时一定要用发送时的数据长度来判断该状态的终止与否，比如我们在发送图二中第一种情况的数据，AXI给的数据是3个，但是发送时实际上是4个，除掉发送FB的状态和FD状态，也就是我们给发送数据状态留两个周期

![image](https://github.com/Vikkdsun/GT/assets/114153159/c8298d8c-aea7-41ec-b2c0-12c24b389cbc)

同样，我们再考虑图二的第二种情况：

![image](https://github.com/Vikkdsun/GT/assets/114153159/51764674-9158-4e97-aaf4-088f3cba6324)

以及后两种情况：

![image](https://github.com/Vikkdsun/GT/assets/114153159/9d37f001-82f6-4dbd-8251-56859b2137b5)

可以看到，第三个状态的周期数主要取决于：1、AXI发过来的数据个数 2、最后一个数据的掩码情况

我们总结为：

#### 发送数据状态周期数 = AXI发过来的数据个数 - 2 + （最后一个数据掩码 >= 1110） ? 1 : 0

这样的话，实际上我们需要用到最后一个数据的掩码，好在AXI流会给一个信号***Last***指示这是最后一个数据，于是我们可以寄存。

但是我们可能使用这个掩码来确定不同的状态吗，比如我们设置更长的数据状态为31，短一点的为32，这是不可能的，因为数据发送状态前的两个周期是固定的，他一定是两个周期，那么这两个周期过去后，这个最后一个数据（LAST）来没来我们不能确定（如图三，比如输入的数据大于4个）

所以不能采用不同状态的方法。

那么只能再数据状态跳转到FD状态上做文章，也就是，***状态计数器（r_st_cnt）***

我们根据图三，可以确定的是，***数据状态开始时刻慢于AXI数据输入时刻***，至少四个周期，这就意味着，在数据状态输出数据的末尾周期时，我们肯定能得到最后一个数据的掩码值，而得到掩码值时，我们肯定***把掩码锁存过了***，因为相差至少4个周期。

锁存过意味着LAST过去了，AXI_VALID已经拉低了，那么我们的跳转条件可以是，***!axi_valid && ((r_st_cnt == len - 3 && save_keep < 1110) || (r_st_cnt == len - 2 && save_keep >= 1110))***

从这个跳转条件中可以看出来，这里我们默认axi发过来的数据大于3，所以就引出了我们讨论的**第二个点**：

***如果数据小于3个怎么办？***

这个问题我们暂且按下，我们继续上面的状态机，现在我们有了状态转移条件

我们从图二可以知道，我们在数据状态输出时，组包的数据不仅要当前周期的数据（比如fifo的out），还需要打一拍的数据（该周期之前的数据）

![image](https://github.com/Vikkdsun/GT/assets/114153159/2fbe5e13-3840-422f-8063-4547d5bd0905)

也就是如图所示，所以我们给输出的数据打一拍

最后，我们如何设置发送FD的状态呢：

![image](https://github.com/Vikkdsun/GT/assets/114153159/d1137dcf-64b1-4639-baf1-9d94277775ad)

我们尝试使用图上所展示的方法，也就是用四种状态。

好了，现在我们该看一下我们的***第二个点***：

***如果数据小于3个怎么办？***

如果数据小于三个，我们讨论数据为2的情况：

![image](https://github.com/Vikkdsun/GT/assets/114153159/b1c38e5c-7b9d-491a-ab20-9223894bd8e0)

如图所示，也就只有前两种情况有发数据的状态，且属于上面4个FD状态的前两个（同时也符合***r_st_cnt == len - 2 && save_keep >= 1110***），后两种都是直接输出FD的状态，而且这两种状态属于上面4个FD状态中的后两个

这意味着，两个数据和多于2个数据的差距只在于是否有发送数据状态，而且只有两种情况没有发送数据状态

而且区分是否有发送数据状态需要用到LAST，我们重新审视图三，如果数据2个时，在发送FB状态我们已经有了LAST和KEEP，这真是太好了，那么我们就可以在FB状态判断是否进入DATA状态了，

那么有：

### 如果在FB状态时，len >= 3：这表示在FB状态前，已经至少输入了3个数据，则跳转到发送数据状态

### 如果在FB状态时，len < 3 ：这表示在FB状态前，数据停止了发送，也就是只有两个数据，那么我们根据Keep选择是否跳过发送数据状态，并且根据KEEP决定跳进FD的第几个状态选择

综上，我们可以画出我们的状态机：

![image](https://github.com/Vikkdsun/GT/assets/114153159/106bb630-4589-4c54-85aa-401a99abf5dc)

0状态是IDLE状态，其跳转条件就是为了达到图三

1状态是发送BC50

2状态是发送FB

3状态是大于等于3个数据时的发送数据状态

4是四种FD状态

5是数据位2个时，并且需要发送状态时的发送状态

最后我们再强调一点。

GT发送时要做到小端发送：

![image](https://github.com/Vikkdsun/GT/assets/114153159/eec39b1c-c265-490d-987c-24b7c5d182db)

这里就不赘述了。

对于数据个数为1的，我们不做讨论，因为涉及到更多状态，比如keep <= 1100那么就没有FD状态了，FB和FB都是同一周期发出去的，但是反之会有FD状态，和2个数据的原理差不多，我们不考虑数据量过少的情况，实际上我们认为数据小于等于2的都不存在。

另一个需要注意的，就是我们的状态机还需要增加一个COMMA状态，因为要利用弹性Buffer（见Readme.md），所以要在不发送数据时，时不时发送同步序列，这里我们设置在IDLE状态每过500周期就要发送一个同步序列，我们设置发送两次BC50BC50。

但是如果500和ri_valid一起到来，我们的优先级还是在发送数据上，此外，如果进入了COMMA状态，这时有ri_valid该怎么办：

![gt_comma](https://github.com/Vikkdsun/GT/assets/114153159/92bb3ebb-4e86-42fe-af97-02c2151ab4bd)

图中主要关注1状态和ri_valid，可以看到ri_valid比1状态早一个周期

![image](https://github.com/Vikkdsun/GT/assets/114153159/dc11cad6-5a6a-4254-93fb-58648e29c761)

图中也要关注1状态和ri_valid，可以看到ri_valid比1状态早一个周期，所以当COMMA状态时检测到ri_valid，就直接跳转到1状态，效果和IDLE跳转到1状态是一样的。


最后，关于ready的控制，***tx_done未拉高，他就不能拉高，所以需要与操作***。



