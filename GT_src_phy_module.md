![image](https://github.com/Vikkdsun/GT/assets/114153159/04b0ead0-98c7-4c59-b6a9-a65ba6c0b100)# 讲解代码Phy_module及其子模块

![image](https://github.com/Vikkdsun/GT/assets/114153159/7366e29d-6a9a-4574-b7a1-3eb5ac1fe551)

## Phy_tx

![image](https://github.com/Vikkdsun/GT/assets/114153159/3b593a74-7cf2-45a5-b248-6bd862fd0f10)

该模块的作用是链接用户端和GT端，我们设定用户端使用AXI_STREAM总线形式将数据发送到本模块，本模块对得到的数据组上同步码、起始码、结束码，再发送到GT收发器

![image](https://github.com/Vikkdsun/GT/assets/114153159/e5410e2a-7ebf-4c38-84c8-59f265849097)

上图我们设为***图一***，图中展示的就是我们想要发给GT的数据格式，其中红色代表***同步码***，蓝色代表***起始码、结束码***，黑色是数据,X代表我们不关心的数据，空格之间的数据为1Byte

![image](https://github.com/Vikkdsun/GT/assets/114153159/5b76ce3c-70b3-4f07-b53a-e0776b631717)

AXI_STREAM传过来的数据主要有以上两个主要信号，上面的代表数据，下面的代表掩码，由于D10后的数据不是用户端想要发送的，所以掩码为这Byte设为0

了解了大概的传输目的，我们要讨论的**第一个点**是：***最后一个数据的掩码可能***

![image](https://github.com/Vikkdsun/GT/assets/114153159/5d9c54e2-00cc-41e5-86c4-b96a81faee59)

图中给出了四种掩码可能，我们只在乎最后一个数据（32bit）的掩码，因为如果传输一个32bit，那么最后一个就是它自身，传输两个32bit，那么第一个32bit一定掩码全1，这也是AXI_STREAM的特点

根据图一我们知道，在组包过程中，FB会使得数据整体后移一位，那么对这四种情况分别讨论：

![image](https://github.com/Vikkdsun/GT/assets/114153159/6e03d718-eac4-4e75-a4a4-bd5a5edc9897)

上图我们设为***图二***，从图中可以看到，虽然AXI发过来的32bit数据个数相同，但是发给GT会变成不同个数，而这种个数的区别就是由AXI发过来的掩码造成的

在写程序时，我们对于组包操作，一般采用***状态机*** + ***FIFO***方式，也就是，发送BC 50 BC 50一个状态、发送FB一个状态（但是实际上这个状态一定也会发送数据）、接着就是发送数据的状态、最后是发送FD的状态（这个状态可能发送数据也可能只发送FB）

我们首先确定一下什么时候进入第一个状态，

![image](https://github.com/Vikkdsun/GT/assets/114153159/5964ab59-8def-4492-af5c-bc2f5e7a934c)

上图我们设为***图三***从图中可以看到，为了数据进入FIFO至少两个周期，我们将在图中位置开始读使能。

我们尝试着画下状态机的时序：

因为发送时32bit数据的长度会+1或不变，所以我们在考虑发送数据状态时一定要用发送时的数据长度来判断该状态的终止与否，比如我们在发送图二中第一种情况的数据，AXI给的数据是3个，但是发送时实际上是4个，除掉发送FB的状态和FD状态，也就是我们给发送数据状态留两个周期

![image](https://github.com/Vikkdsun/GT/assets/114153159/c8298d8c-aea7-41ec-b2c0-12c24b389cbc)

同样，我们再考虑图二的第二种情况：

![image](https://github.com/Vikkdsun/GT/assets/114153159/51764674-9158-4e97-aaf4-088f3cba6324)

以及后两种情况：

![image](https://github.com/Vikkdsun/GT/assets/114153159/9d37f001-82f6-4dbd-8251-56859b2137b5)

可以看到，第三个状态的周期数主要取决于：1、AXI发过来的数据个数 2、最后一个数据的掩码情况

我们总结为：

#### 发送数据状态周期数 = AXI发过来的数据个数 - 2 + （最后一个数据掩码 >= 1110） ? 1 : 0

这样的话，实际上我们需要用到最后一个数据的掩码，好在AXI流会给一个信号***Last***指示这是最后一个数据，于是我们可以寄存。

但是我们可能使用这个掩码来确定不同的状态吗，比如我们设置更长的数据状态为31，短一点的为32，这是不可能的，因为数据发送状态前的两个周期是固定的，他一定是两个周期，那么这两个周期过去后，这个最后一个数据（LAST）来没来我们不能确定（如图三，比如输入的数据大于4个）

所以不能采用不同状态的方法。

那么只能再数据状态跳转到FD状态上做文章，也就是，***状态计数器（r_st_cnt）***

我们根据图三，可以确定的是，***数据状态开始时刻慢于AXI数据输入时刻***，至少四个周期，这就意味着，在数据状态输出数据的末尾周期时，我们肯定能得到最后一个数据的掩码值，而得到掩码值时，我们肯定***把掩码锁存过了***，因为相差至少4个周期。

锁存过意味着LAST过去了，AXI_VALID已经拉低了，那么我们的跳转条件可以是，***!axi_valid && ((r_st_cnt == len - 3 && save_keep < 1110) || (r_st_cnt == len - 2 && save_keep >= 1110))***

从这个跳转条件中可以看出来，这里我们默认axi发过来的数据大于3，所以就引出了我们讨论的**第二个点**：

***如果数据小于3个怎么办？***

这个问题我们暂且按下，我们继续上面的状态机，现在我们有了状态转移条件

我们从图二可以知道，我们在数据状态输出时，组包的数据不仅要当前周期的数据（比如fifo的out），还需要打一拍的数据（该周期之前的数据）

![image](https://github.com/Vikkdsun/GT/assets/114153159/2fbe5e13-3840-422f-8063-4547d5bd0905)

也就是如图所示，所以我们给输出的数据打一拍

最后，我们如何设置发送FD的状态呢：

![image](https://github.com/Vikkdsun/GT/assets/114153159/d1137dcf-64b1-4639-baf1-9d94277775ad)

我们尝试使用图上所展示的方法，也就是用四种状态。

好了，现在我们该看一下我们的***第二个点***：

***如果数据小于3个怎么办？***

如果数据小于三个，我们讨论数据为2的情况：

![image](https://github.com/Vikkdsun/GT/assets/114153159/b1c38e5c-7b9d-491a-ab20-9223894bd8e0)

如图所示，也就只有前两种情况有发数据的状态，且属于上面4个FD状态的前两个（同时也符合***r_st_cnt == len - 2 && save_keep >= 1110***），后两种都是直接输出FD的状态，而且这两种状态属于上面4个FD状态中的后两个

这意味着，两个数据和多于2个数据的差距只在于是否有发送数据状态，而且只有两种情况没有发送数据状态

而且区分是否有发送数据状态需要用到LAST，我们重新审视图三，如果数据2个时，在发送FB状态我们已经有了LAST和KEEP，这真是太好了，那么我们就可以在FB状态判断是否进入DATA状态了，

那么有：

### 如果在FB状态时，len >= 3：这表示在FB状态前，已经至少输入了3个数据，则跳转到发送数据状态

### 如果在FB状态时，len < 3 ：这表示在FB状态前，数据停止了发送，也就是只有两个数据，那么我们根据Keep选择是否跳过发送数据状态，并且根据KEEP决定跳进FD的第几个状态选择

综上，我们可以画出我们的状态机：

![image](https://github.com/Vikkdsun/GT/assets/114153159/106bb630-4589-4c54-85aa-401a99abf5dc)

0状态是IDLE状态，其跳转条件就是为了达到图三

1状态是发送BC50

2状态是发送FB

3状态是大于等于3个数据时的发送数据状态

4是四种FD状态

5是数据位2个时，并且需要发送状态时的发送状态

最后我们再强调一点。

GT发送时要做到小端发送：

![image](https://github.com/Vikkdsun/GT/assets/114153159/eec39b1c-c265-490d-987c-24b7c5d182db)

这里就不赘述了。

对于数据个数为1的，我们不做讨论，因为涉及到更多状态，比如keep <= 1100那么就没有FD状态了，FB和FB都是同一周期发出去的，但是反之会有FD状态，和2个数据的原理差不多，我们不考虑数据量过少的情况，实际上我们认为数据小于等于2的都不存在。

另一个需要注意的，就是我们的状态机还需要增加一个COMMA状态，因为要利用弹性Buffer（见Readme.md），所以要在不发送数据时，时不时发送同步序列，这里我们设置在IDLE状态每过500周期就要发送一个同步序列，我们设置发送两次BC50BC50。

但是如果500和ri_valid一起到来，我们的优先级还是在发送数据上，此外，如果进入了COMMA状态，这时有ri_valid该怎么办：

![gt_comma](https://github.com/Vikkdsun/GT/assets/114153159/92bb3ebb-4e86-42fe-af97-02c2151ab4bd)

图中主要关注1状态和ri_valid，可以看到ri_valid比1状态早一个周期

![image](https://github.com/Vikkdsun/GT/assets/114153159/dc11cad6-5a6a-4254-93fb-58648e29c761)

图中也要关注1状态和ri_valid，可以看到ri_valid比1状态早一个周期，所以当COMMA状态时检测到ri_valid，就直接跳转到1状态，效果和IDLE跳转到1状态是一样的。


最后，关于ready的控制，***tx_done未拉高，他就不能拉高，所以需要与操作***。




## Phy_rx

![image](https://github.com/Vikkdsun/GT/assets/114153159/10738c53-3152-4130-9162-66ec9622a861)

Phy_rx的端口和tx正好相反，他是把GT端口数据转成AXI_STREAM

这里需要注意的是，GT只能做字节对齐，但是不会做32bit对齐，也就是比如发送端发送的是第一个32bit是BC 50 BC 50，但是接收时第一个有关的32bit可能是X X BC 50

所以这里要分很多复杂的情况来讨论：

![image](https://github.com/Vikkdsun/GT/assets/114153159/5790af43-bae1-4031-b68f-8b1e490dd8d8)

首先找BC 50 FB，为什么不找BC 50 BC 50 FB呢，因为同步码可能会被丢掉，由于***弹性Buffer的上溢***，所以我们只找BC 50 FB，同时我们主要是找FB的位置，图中可以看到，data为当前时刻的数据，data_1d为打一拍的数据（上一时刻的数据），found_fb是一个脉冲，表示我们找到了FB（寻找FB需要找BC 50 FB，再次强调，这也是为什么我们要做一个打一拍），local为FB在***当前数据***的位置，但是我们会发现，第一个情况下，Tb+1时，有D（FB后的数据）的是data而不是data_1d

![image](https://github.com/Vikkdsun/GT/assets/114153159/42e4d7e7-96b7-4f0a-a45b-a4b83ea38337)

图中展示的是输出数据怎么控制，根据local的不同控制方式也不同

![image](https://github.com/Vikkdsun/GT/assets/114153159/2a6c9f60-9e96-4a51-b3e9-3557da3f368c)

然后找FD，可以看到，FD似乎更简单，但是FD的四种情况在FB的四种情况下，会变得复杂，我们讨论一下

>***如果FD是第四种情况，那么最后一个输出只是一个FD***
>***对于FB的第一种情况，也就是FB在最前面***

>![image](https://github.com/Vikkdsun/GT/assets/114153159/b8ea7048-9beb-44ad-8896-1c120b07d23e)

>我们要明确 eof是用来确定eof下个周期数据的keep以及eof下个周期是last，但是上图很明显eof慢了两个周期，如果对数据打3拍，创造data 1d 2d 3d这样太复杂了，另一种方法就是只打两拍，让eof比现在提前一个周期，然后我们把数据整体打一拍，此外不使用eof下个周期的last而是直接用eof做last，然后创造valid，valid要打一拍，eof也打一拍作为打拍后的last

>***对于FB的第二种情况***

>![image](https://github.com/Vikkdsun/GT/assets/114153159/00c2c0ca-77cb-45f9-a26d-80ab7dc97cb1)

>我们其实只需要也对eof提前一个周期拉高，就可以不用对data、valid等信号打拍了，但是为了和第一种情况相似，我们不用eof提前，而是也使用data、valid打拍的方式，那么我们也可以知道，对于FB的2、3、4三种情况，FD的第四种情况，都是这里讨论的情况，***处理方式相同***

>***如果FD是第三种情况***
>***对于FB的第一种情况，也就是FB在最前面***

![image](https://github.com/Vikkdsun/GT/assets/114153159/3944b6fd-8cd3-4e95-98f2-8e2fbf0ab87a)

>从eof和valid的下降沿关系可以看出，这种情况和上面讨论的第二种情况一样，那么操作方式也一样，不对eof提前，而是data、valid打拍

>***对于FB的第二种情况***

>![image](https://github.com/Vikkdsun/GT/assets/114153159/4ab4384a-6aa7-4083-89f5-da56270eeb78)

>其也和上面的情况一样，类比我们可以知道FB的2 3 4情况也是如此
>
>***如果FD是第二种情况***
>***对于FB的第一种情况，也就是FB在最前面***
>
>这里其实不需要画图了，类比FD3FB1的情况我们可以知道，其处理方法也是eof不动，data、valid打拍
>
>***对于FB的第二种情况***
>
>同理 2 3FB都是这样操作
>
>***对于FB第4种情况***

>![image](https://github.com/Vikkdsun/GT/assets/114153159/1d79c987-f840-42b4-aa92-d1778a6ffe20)

>为了保证也是data、valid打一拍，我们这里让eof晚触发一拍

>***如果FD是第一种情况***
>***对于FB的第一种情况，也就是FB在最前面***

>一样的
>
>***对于FB的第二种情况***
>
>还是一样
>
>***对于FB的第三种情况***
>
>其实和上面的FB4FD2一样，eof晚触发，那么FB第四种情况也一样
>

### 综上我们可以概括一下

### 早触发eof的情况：为什么会有早触发eof，就是因为eof拉高的这个周期，输出的data是单独的FD，也可以说是***eof晚于valid下降沿***所以在这里只有一种情况，也就是eof前一个周期采集的数据只有FD，即FB为第一种情况，FD是第四种情况（FB是第一种情况意味着在采集时只要中间时序（我们假定提前一个周期的是提前时序的data，落后的是落后时序data，中间是中间时序）的全部data，那么FD是第四种情况意味着在eof拉高时，采集到的中间时序只有一个FD）。也可以说***落后时序采集0，FD前数据为0，和为0的情况为早出发***

### 正常触发eof的情况：正常触发eof的情况，就是在eof拉高的这个周期，输出的数据是1-4个byte的正常数据，而且在下一个周期没有数据输出，也可以说是***eof和valid下降沿同时***这种情况比较多，不列举了。也可以说***落后时序采集a，FD前数据为b，a+b<= 4的情况***

### 晚触发eof的情况：晚触发eof的情况是因为在eof拉高这个周期，输出数据是4byte而且下个周期还有数据输出，也可以说是***eof比valid下降沿早一个周期***，会出现这种情况的就是***落后时序采集的字节数量加FD右边的字节数量和大于4的情况***




